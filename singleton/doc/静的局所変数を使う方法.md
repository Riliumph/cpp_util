# 静的局所変数を使う方法

staticなローカル変数を用いることでスレッドセーフなシングルトンをサクッと構築する人は多い。

## 具体的な実装

```c++
class Foo
{
private:
    Foo() = default;
    ~Foo() = default;

public:
    Foo(const Foo&) = delete;
    Foo& operator=(const Foo&) = delete;
    Foo(Foo&&) = delete;
    Foo& operator=(Foo&&) = delete;

    static Foo& Get()
    {
        static Foo instance;
        return instance;
    }
};
```

## メリット

1. 何よりも実装が簡単！！
1. 静的初期化が行われるのでスレッドセーフである

## デメリット

右を見れば左があるみたいな意見にはなるが、メリットを否定していこう。

実装が簡単なのは、いろんな機能を捨てているからである。  
例えば、静的変数を使っているがゆえに簡単なのだが、静的変数ゆえに解放タイミングを選べないことが問題だ。

基本的にC++はRAIIの概念に基づきデストラクタでリソースを開放する。  
つまり、コンストラクタとは逆順にリソースを開放する手段が用意ないしは、実装する場所が提供されている。

静的変数のリソース生成・解放タイミングはいつだろうか？  
リソースの生成はプログラムの実行された直後に行われる。  
リソースの解放はプログラムが終了した後に行われる。

プログラムが終了する手前ではない。終了した後に行われるらしい。  

> それって、カーネルがメモリをスイープすることを意味してる？？？

### 困るパターン１：リセットできない

システムで単一のキャッシュ機構を作る際に困る。  
それはデータのキャッシュでもいいし、DBの接続プールでもいい。

リソースの解放を任意のタイミングで行いたい場合に、プログラムが終了したタイミングしかできないのは困る。

### 困るパターン２：設定のリロードができない

これもリセットができないに等しい。  

例えば、システムの設定をシングルトンで実装している場合、SIGHUPを受信したら設定をリロードしたいなんてのはよくある話である。  
しかし、システムの終了時しかインスタンスを手放さないならそれもできない。

### 困るパターン３：テストできない？

単体テストで、テストケース毎にクリーンな状態を作ろうにもプログラム終了時にのみ開放するのであればテストもやりにくい。
