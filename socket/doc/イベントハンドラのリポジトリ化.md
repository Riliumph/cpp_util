# イベントハンドラのリポジトリ化

Clean Architectureを学んでいると、継承ではなく委譲を用いたリポジトリパターンを考えてしまう。  
今回のソケットサーバークラスはイベントハンドラを自由に組み替えたい。  
そこで、イベントハンドラクラスをリポジトリパターンで渡すことは可能か？

## リポジトリパターン

リポジトリパターンは、業務ロジックを担当するインタラクタにリポジトリを渡す。  
どこにファイルを保存するかといったロジックがリポジトリクラスに一任されることで、業務ロジックはその思想から解放される。

つまり、DBに接続して保存するのか、モックとしてテキストに書き出すのかを業務ロジックではなく、さらに外部のプログラマーが選択できるという利点を手に入れたことになる。

これにより、テストの時はモックリポジトリを使い、本番はDBリポジトリを使うなどという風に使いわけることができる。

## では、サーバークラス

サーバークラスはこれに当たるだろうか？

よく考えると、リポジトリパターンとは、受け取ったリポジトリクラスを外部に晒すことなくインタラクタ内に閉じ込めて使っているのが特徴ではないだろうか？

これを踏まえてリポジトリパターンでの実装を見てみよう。

```c++
namespace nw::ipv4::tcp {
class Server : public nw::IF::Server
{
public: // constructor
  Server(std::unique_ptr<event::IF::EventHandler>,
         const u_short,
         const struct addrinfo);
  bool EventLoop(std::function<bool(int)>);
  /*省略*/
}
}
```

なるほど。  
これで、どんなイベントだろうが外から選べるわけだ。

で、どうやってイベントループを使うのか？  
インターフェイスである`EventLoop`メソッドで行う。

これでサーバーがEvent処理をサポートしていることが外部からでもわかる。

### どうやって色んなイベントハンドラを設定するか？

各種サーバー（TCPとかUDPとか）に対して、いろんなイベントハンドラ（select, epoll）をどうやって設定する？

#### 継承？

継承は簡単だ。  
イベントハンドラのクラスを継承したサーバーを作る。  
ただ、IPv4 TCP, IPv6 TCP, IPv4 UDP, IPv6 UDPとSelect, Epollの組み合わせだと８通りの実装が必要だ。

……面倒くさい……。  
パターンが増えるたびに実装が増える。

それに、サーバークラスでイベントハンドラを使うだけで、サーバークラスを通して外部のロジックがイベントハンドラを使いたいわけじゃない。  
つまり、別にサーバークラスでイベントハンドラのIFを公開する必要は一ミリもない。

継承するべきじゃないな。。。

#### 委譲？

委譲するならリポジトリパターンを採用したい。

こっちの方が良くない？
