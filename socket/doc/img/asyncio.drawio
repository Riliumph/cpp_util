<mxfile host="Electron" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/26.1.1 Chrome/132.0.6834.210 Electron/34.3.3 Safari/537.36" version="26.1.1">
  <diagram name="ページ1" id="CVDL1Krlui7HTQANblH1">
    <mxGraphModel dx="2073" dy="1191" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="tjGFO5WkhEhIEGK9zRMH-5" value="Process" style="" parent="0" />
        <mxCell id="HY2eR0e-hWTVf-RodTzT-3" value="Process&lt;div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;&lt;b&gt;【生成方法】&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;fork system callでProcess&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;を複製&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;し、execve system callで&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;Process内容を上書きすることで生成。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;【管理方法】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;Kernel空間で管理される。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;task_struct構造体で表現され、Linuxの&lt;/span&gt;Completely Fair Schedularで管理される。&lt;/div&gt;&lt;div&gt;Linuxにとって、ProcessとThreadに管理的差異は無い。&lt;/div&gt;&lt;div&gt;sleep(), wait()などで操作し、CPUのスケジュールを制御可能。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;&lt;b&gt;【並列・並行】&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;CFSによりマルチコア環境では並列処理で、シングルコア環境では並行で動作する。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;【メモリ空間】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;単独のメモリ空間を持つ。&lt;/div&gt;&lt;div&gt;&lt;b&gt;【&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;コンテキストスイッチ・&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;コスト】&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(90, 108, 134), rgb(132, 148, 170));&quot;&gt;プロセス生成時にメモリ空間とCPUレジスタの完全切り替えを行うため非常に重たい&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;" style="points=[[0,0],[0.25,0],[0.5,0],[0.75,0],[1,0],[1,0.25],[1,0.5],[1,0.75],[1,1],[0.75,1],[0.5,1],[0.25,1],[0,1],[0,0.75],[0,0.5],[0,0.25]];outlineConnect=0;gradientColor=none;html=1;whiteSpace=wrap;fontSize=12;fontStyle=0;container=0;pointerEvents=0;collapsible=0;recursiveResize=0;shape=mxgraph.aws4.group;grIcon=mxgraph.aws4.group_on_premise;strokeColor=#7D8998;fillColor=none;verticalAlign=top;align=left;spacingLeft=30;fontColor=#5A6C86;dashed=0;" vertex="1" parent="tjGFO5WkhEhIEGK9zRMH-5">
          <mxGeometry x="40" y="40" width="720" height="1080" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-8" value="Memory" style="fillColor=none;strokeColor=#DD3522;verticalAlign=top;fontStyle=0;fontColor=#DD3522;whiteSpace=wrap;html=1;" vertex="1" parent="tjGFO5WkhEhIEGK9zRMH-5">
          <mxGeometry x="80" y="280" width="640" height="800" as="geometry" />
        </mxCell>
        <mxCell id="tjGFO5WkhEhIEGK9zRMH-7" value="Thread" style="" parent="0" />
        <mxCell id="HY2eR0e-hWTVf-RodTzT-5" value="Thread&lt;div&gt;&lt;div&gt;&lt;b&gt;【生成方法】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;プロセスを複製する&lt;/span&gt;clone system callに以下のリソース共有フラグを自由に加えて生成。&lt;/div&gt;&lt;div&gt;リソース共有フラグ類：&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;PID共有、&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;メモリ共有、FD共有、etc...&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;【管理方法】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Kernel空間で管理される。&lt;/div&gt;&lt;div&gt;Thread毎にtask_struct構造体で表現されるが、同じProcessのmm（メモリ情報）を共有する。&lt;/div&gt;&lt;div&gt;Processと同様のtask_structのため、LinuxのCFSで管理される。&lt;/div&gt;&lt;div&gt;Linuxにとって、ProcessとThreadに管理的差異は無い。&lt;/div&gt;&lt;div&gt;mutex, condition_variableなどで操作し、メモリの上書きなどを制御可能。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;【並列・並行】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;プロセスと同じ扱いのため、プロセス参照。&lt;/div&gt;&lt;div&gt;&lt;b&gt;【メモリ空間】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;メモリ共有フラグを持ったtask_structのため、別スレッドとも&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;メモリ空間を共有する&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;【コンテキストスイッチ・コスト】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;スレッド生成時のコンテキストスイッチは、メモリは切り替えないがレジスタとスタックを切り替えるため、そこそこに重たい&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="points=[[0,0],[0.25,0],[0.5,0],[0.75,0],[1,0],[1,0.25],[1,0.5],[1,0.75],[1,1],[0.75,1],[0.5,1],[0.25,1],[0,1],[0,0.75],[0,0.5],[0,0.25]];outlineConnect=0;gradientColor=none;html=1;whiteSpace=wrap;fontSize=12;fontStyle=0;container=0;pointerEvents=0;collapsible=0;recursiveResize=0;shape=mxgraph.aws4.group;grIcon=mxgraph.aws4.group_region;strokeColor=#00A4A6;fillColor=none;verticalAlign=top;align=left;spacingLeft=30;fontColor=#147EBA;dashed=1;" vertex="1" parent="tjGFO5WkhEhIEGK9zRMH-7">
          <mxGeometry x="120" y="320" width="480" height="720" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-15" value="" style="points=[[0,0],[0.25,0],[0.5,0],[0.75,0],[1,0],[1,0.25],[1,0.5],[1,0.75],[1,1],[0.75,1],[0.5,1],[0.25,1],[0,1],[0,0.75],[0,0.5],[0,0.25]];outlineConnect=0;gradientColor=none;html=1;whiteSpace=wrap;fontSize=12;fontStyle=0;container=0;pointerEvents=0;collapsible=0;recursiveResize=0;shape=mxgraph.aws4.group;grIcon=mxgraph.aws4.group_region;strokeColor=#00A4A6;fillColor=none;verticalAlign=top;align=left;spacingLeft=30;fontColor=#147EBA;dashed=1;" vertex="1" parent="tjGFO5WkhEhIEGK9zRMH-7">
          <mxGeometry x="640" y="320" width="40" height="720" as="geometry" />
        </mxCell>
        <mxCell id="tjGFO5WkhEhIEGK9zRMH-34" value="coroutin" parent="0" />
        <mxCell id="HY2eR0e-hWTVf-RodTzT-14" value="coroutine&lt;div&gt;&lt;div&gt;&lt;b&gt;【生成方法】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;言語やライブラリで提供されている方法&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;&lt;b&gt;【管理方法】&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;User空間で管理される。&lt;/div&gt;&lt;div&gt;Kernelが介在しないため、スケジューラをユーザが用意する必要がある。&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;基本的にOSのイベント駆動機能を使って実現されていることが多い。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;&lt;b&gt;【並列・並行性】&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;ユーザー実装のため言語やライブラリの違いがある。&lt;/div&gt;&lt;div&gt;よくあるのはシングルスレッド＋非同期IOによる並行実行である。&lt;/div&gt;&lt;div&gt;ただし、最近はスレッドを使って並列実行をサポートする環境も多い。&lt;/div&gt;&lt;div&gt;&lt;b&gt;【メモリ空間】&lt;/b&gt;&lt;/div&gt;&lt;div&gt;User空間で管理されるためメモリ空間という概念が存在しない。&lt;/div&gt;&lt;div&gt;各タスク間での&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;変数の共有にはcontextと呼ばれる概念を使うことが多い。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;&lt;b&gt;【コンテキストスイッチ・コスト】&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;非同期I/Oを使う場合、Kernelへの非同期(&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;O_NONBLOCK)設定をした&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;system callをした際にスケジューラに登録されて、別のコルーチンへスイッチする。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;原理は関数呼び出しのためコストはコールコストのみで非常に小さい。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;" style="points=[[0,0],[0.25,0],[0.5,0],[0.75,0],[1,0],[1,0.25],[1,0.5],[1,0.75],[1,1],[0.75,1],[0.5,1],[0.25,1],[0,1],[0,0.75],[0,0.5],[0,0.25]];outlineConnect=0;gradientColor=none;html=1;whiteSpace=wrap;fontSize=12;fontStyle=0;container=1;pointerEvents=0;collapsible=0;recursiveResize=0;shape=mxgraph.aws4.group;grIcon=mxgraph.aws4.group_security_group;grStroke=0;strokeColor=#00A4A6;fillColor=#E6F6F7;verticalAlign=top;align=left;spacingLeft=30;fontColor=#147EBA;dashed=0;" vertex="1" parent="tjGFO5WkhEhIEGK9zRMH-34">
          <mxGeometry x="160" y="640" width="400" height="370" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-18" value="sample" parent="0" />
        <mxCell id="HY2eR0e-hWTVf-RodTzT-19" value="C++&lt;div&gt;&lt;div&gt;#include &amp;lt;iostream&amp;gt;&lt;/div&gt;&lt;div&gt;#include &amp;lt;thread&amp;gt;&lt;/div&gt;&lt;div&gt;#include &amp;lt;future&amp;gt;&lt;/div&gt;&lt;div&gt;#include &amp;lt;chrono&amp;gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;void task1() {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::cout &amp;lt;&amp;lt; &quot;Task 1: Started&quot; &amp;lt;&amp;lt; std::endl;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::this_thread::sleep_for(std::chrono::seconds(2));&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::cout &amp;lt;&amp;lt; &quot;Task 1: Completed&quot; &amp;lt;&amp;lt; std::endl;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;void task2() {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::cout &amp;lt;&amp;lt; &quot;Task 2: Started&quot; &amp;lt;&amp;lt; std::endl;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::this_thread::sleep_for(std::chrono::seconds(1));&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::cout &amp;lt;&amp;lt; &quot;Task 2: Completed&quot; &amp;lt;&amp;lt; std::endl;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;int main() {&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&amp;nbsp; &amp;nbsp; std::future&amp;lt;void&amp;gt; task1_obj = std::async(std::launch::async, task1);&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::future&amp;lt;void&amp;gt; task2_obj = std::async(std::launch::async, task2);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&amp;nbsp; &amp;nbsp; task1_obj.get();&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; task2_obj.get();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; return 0;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="HY2eR0e-hWTVf-RodTzT-18">
          <mxGeometry x="80" y="1160" width="400" height="400" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-20" value="Python&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;import asyncio&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;async def task1():&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; print(&quot;Task 1: Started&quot;)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; await asyncio.sleep(2)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; print(&quot;Task 1: Completed&quot;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;async def task2():&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; print(&quot;Task 2: Started&quot;)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; await asyncio.sleep(1)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; print(&quot;Task 2: Completed&quot;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;async def main():&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&amp;nbsp; &amp;nbsp; task1_obj = asyncio.create_task(task1())&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; task2_obj = asyncio.create_task(task2())&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&amp;nbsp; &amp;nbsp; await task1_obj&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; await task2_obj&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;asyncio.run(main())&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="HY2eR0e-hWTVf-RodTzT-18">
          <mxGeometry x="520" y="1160" width="240" height="400" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-21" value="Go&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;package main&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;import (&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;&quot;time&quot;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;func task1() {&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;fmt.Println(&quot;Task 1: Started&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;time.Sleep(2 * time.Second)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;fmt.Println(&quot;Task 1: Completed&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;func task2() {&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;fmt.Println(&quot;Task 2: Started&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;time.Sleep(1 * time.Second)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;fmt.Println(&quot;Task 2: Completed&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;func main() {&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255)); white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;go task1()&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;go task2()&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;// 並行して実行するタスクの完了を待つために少し待機&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;// 通常はsync.WaitGroupなどを使うが面倒なので&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&#x9;&lt;/span&gt;time.Sleep(3 * time.Second)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="HY2eR0e-hWTVf-RodTzT-18">
          <mxGeometry x="800" y="1160" width="360" height="440" as="geometry" />
        </mxCell>
        <mxCell id="HY2eR0e-hWTVf-RodTzT-23" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(20, 126, 186); background-color: transparent;&quot;&gt;【C++20 or Boost.Asio】&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(20, 126, 186); background-color: transparent;&quot;&gt;C++20ではcoroutineはスレッドで実現される。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(20, 126, 186); background-color: transparent;&quot;&gt;std::asyncが提供するスレッドプールで動作する。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: rgb(20, 126, 186);&quot;&gt;イベント駆動を実現する場合、Linuxのepollを使ってスケジューラを自作する必要がある。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: rgb(20, 126, 186);&quot;&gt;Boost.Asioを使う場合、epollで実装されているio_contextスケジューラで動作させられる。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: rgb(20, 126, 186);&quot;&gt;【&lt;/span&gt;&lt;span style=&quot;color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212)); background-color: transparent;&quot;&gt;Python asyncio framework】&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212)); background-color: transparent;&quot;&gt;asyncio.gatherを使えばスレッドプールで動作する。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212)); background-color: transparent;&quot;&gt;asyncio.create_taskなどを使えばepollで実装されているEventLoopスケジューラで動作させられる。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;【Go】&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;coroutine概念に則って実装されているGo管理のユーザースレッド（&lt;/span&gt;&lt;span style=&quot;color: rgb(20, 126, 186); background-color: transparent;&quot;&gt;goroutine&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;）で実現される。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;go runtimeの提供するM:Nスケジューラで動作する。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(20, 126, 186);&quot;&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;M=Machine=OSスレッドのこと。N=Network=goroutineのこと。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(20, 126, 186);&quot;&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;M:Nスケジューラは適度な数のgoroutineを処理をOSスケジューラに渡して並列化する。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(20, 126, 186);&quot;&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(20, 126, 186), rgb(69, 160, 212));&quot;&gt;（いわゆるグリーンスレッド）&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(20, 126, 186);&quot;&gt;イベント駆動を実現する場合は、スケジューラの自作が必要。&lt;/div&gt;&lt;div style=&quot;color: rgb(20, 126, 186);&quot;&gt;しかし、そもそもgoroutine自体が軽量スレッドのため言語機能のgorutineとchannelで十分とされている。&lt;/div&gt;" style="shape=callout;whiteSpace=wrap;html=1;perimeter=calloutPerimeter;size=50;position=0.04;position2=0;align=left;base=40;" vertex="1" parent="HY2eR0e-hWTVf-RodTzT-18">
          <mxGeometry x="600" y="530" width="520" height="370" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
